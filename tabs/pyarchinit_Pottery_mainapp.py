#! /usr/bin/env python# -*- coding: utf 8 -*-"""/***************************************************************************        pyArchInit Plugin  - A QGIS plugin to manage archaeological dataset                             stored in Postgres                             -------------------    begin                : 2007-12-01    copyright            : (C) 2008 by Luca Mandolesi    email                : mandoluca at gmail.com ***************************************************************************//*************************************************************************** *                                                                                                                  * *   This program is free software; you can redistribute it and/or modify                           * *   it under the terms of the GNU General Public License as published by                       * *   the Free Software Foundation; either version 2 of the License, or                              * *   (at your option) any later version.                                                                    * *                                                                                                                  * ***************************************************************************/"""from __future__ import absolute_importimport osfrom datetime import dateimport sysimport platformfrom builtins import rangefrom builtins import strfrom datetime import datefrom qgis.core import QgsSettingsfrom qgis.PyQt.QtCore import Qt, QSize, pyqtSlot, QLocalefrom qgis.PyQt.QtGui import QColor, QIconfrom qgis.PyQt.QtWidgets import QDialog, QMessageBox, QListWidget, QListView, QFrame, QAbstractItemView, QTableWidgetItem, QListWidgetItemfrom qgis.PyQt.uic import loadUiTypefrom qgis.gui import QgsMapCanvas, QgsMapToolPanfrom ..modules.utility.pyarchinit_exp_POTTERYsheet_pdf import generate_POTTERY_pdffrom ..modules.utility.pyarchinit_OS_utility import Pyarchinit_OS_Utilityfrom ..modules.db.pyarchinit_conn_strings import Connectionfrom ..modules.db.pyarchinit_db_manager import Pyarchinit_db_managementfrom ..modules.db.pyarchinit_utility import Utilityfrom ..modules.gis.pyarchinit_pyqgis import Pyarchinit_pyqgisfrom ..modules.utility.delegateComboBox import ComboBoxDelegatefrom ..modules.utility.pyarchinit_error_check import Error_checkfrom ..gui.imageViewer import ImageViewerfrom ..gui.sortpanelmain import SortPanelMainfrom ..gui.quantpanelmain import QuantPanelMainMAIN_DIALOG_CLASS, _ = loadUiType(    os.path.join(os.path.dirname(__file__), os.pardir, 'gui', 'ui', 'pyarchinit_Pottery_ui.ui'))class pyarchinit_Pottery(QDialog, MAIN_DIALOG_CLASS):    MSG_BOX_TITLE = "HFF - Pottery Form"    DATA_LIST = []    DATA_LIST_REC_CORR = []    DATA_LIST_REC_TEMP = []    REC_CORR = 0    REC_TOT = 0    STATUS_ITEMS = {"b": "Current", "f": "Find", "n": "New Record"}    BROWSE_STATUS = "b"    SORT_MODE = 'asc'    SORTED_ITEMS = {"n": "Not sorted", "o": "Sorted"}    SORT_STATUS = "n"    SORT_ITEMS_CONVERTED = ''    UTILITY = Utility()    DB_MANAGER = ""    TABLE_NAME = 'pottery_table'    MAPPER_TABLE_CLASS = "POTTERY"    NOME_SCHEDA = "Pottery Form"    ID_TABLE = "id_rep"    CONVERSION_DICT = {    ID_TABLE:ID_TABLE,    "ID Number":"id_number",    "Sito":"sito",    "Area":"area",    "US":"us",    "Box":"box",    "Photo":"photo",    "Drawing":"drawing",    "Year":"anno",    "Fabric":"fabric",    "Percent":"percent",    "Material":"material",    "Shape":"form",    "Specific form":"specific_form",    "Ware":"ware",    "Munsell color":"munsell",    "Surface treatment":"surf_trat",    "External decoration":"exdeco",    "Internal decoration":"intdeco",    "Wheel made":"wheel_made",    "Description external decoration":"descrip_ex_deco",    "Description internal decoration":"descrip_in_deco",    "Note":"note",    "Diameter Max":"diametro_max",    "QTY":"qty",    "Diameter Rim":"diametro_rim",    "Diameter Bottom":"diametro_bottom",    "Total height":"diametro_height",    "Preserved height":"diametro_preserved",    "Specific shape":"specific_shape",    "Bag":"bag"    }    SORT_ITEMS = [                ID_TABLE,                 "ID Number",                "Sito",                "Area",                 "US",                "Box",                "Photo",                "Drawing",                "Year",                "Fabric",                "Percent",                "Material",                "Shape",                "Specific form",                "Ware",                "Munsell color",                "Surface treatment",                "External decoration",                "Internal decoration",                "Wheel made",                "Description external decoration",                "Description internal decoration",                "Note",                "Diameter Max",                "QTY",                "Diameter Rim",                "Diameter Bottom",                "Total height",                "Preserved height",                "Specific shape",                "Bag",                ]    QUANT_ITEMS = [                'Fabric',                'US',                'Area',                'Material',                'Percent',                'Shape',                'Specific form',                'Ware',                'Munsell color',                'Surface treatment',                'External decoration',                'Internal decoration',                'Wheel made',                ]                                TABLE_FIELDS_UPDATE = [                    "id_number",                     "sito",                    "area",                    "us",                    "box",                    "photo",                    "drawing",                    "anno",                    "fabric",                    "percent",                    "material",                    "form",                    "specific_form",                    "ware",                    "munsell",                    "surf_trat",                    "exdeco",                    "intdeco",                    "wheel_made",                    "descrip_ex_deco",                    "descrip_in_deco",                    "note",                    "diametro_max",                    "qty",                    "diametro_rim",                    "diametro_bottom",                    "diametro_height",                    "diametro_preserved",                    "specific_shape",                    "bag",                    ]                           TABLE_FIELDS = [                    "id_number",                     "sito",                    "area",                    "us",                    "box",                    "photo",                    "drawing",                    "anno",                    "fabric",                    "percent",                    "material",                    "form",                    "specific_form",                    "ware",                    "munsell",                    "surf_trat",                    "exdeco",                    "intdeco",                    "wheel_made",                    "descrip_ex_deco",                    "descrip_in_deco",                    "note",                    "diametro_max",                    "qty",                    "diametro_rim",                    "diametro_bottom",                    "diametro_height",                    "diametro_preserved",                    "specific_shape",                    "bag",                    ]           DB_SERVER = "not defined"  ####nuovo sistema sort            def __init__(self, iface):        super().__init__()        self.iface = iface        self.setupUi(self)        self.currentLayerId = None        HOME = os.environ['PYARCHINIT_HOME']        try:            self.on_pushButton_connect_pressed()        except Exception as e:            QMessageBox.warning(self, "Connection System", str(e), QMessageBox.Ok)        site = self.comboBox_sito.currentText()        self.comboBox_sito.setEditText(site)        self.fill_fields()        self.customize_GUI()        def on_pushButtonQuant_pressed(self):        dlg = QuantPanelMain(self)        dlg.insertItems(self.QUANT_ITEMS)        dlg.exec_()        dataset = []                parameter1 = dlg.TYPE_QUANT        parameters2 = dlg.ITEMS        #QMessageBox.warning(self, "Test Parametri Quant", str(parameters2),  QMessageBox.Ok)                contatore = 0        #tipi di quantificazione        ##per forme minime        if parameter1 == 'QTY':            for i in range(len(self.DATA_LIST)):                temp_dataset = ()                try:                    temp_dataset = (self.parameter_quant_creator(parameters2, i), int(self.DATA_LIST[i].qty))                                        contatore += int(self.DATA_LIST[i].qty) #conteggio totale                                        dataset.append(temp_dataset)                except:                    pass            #QMessageBox.warning(self, "Totale", str(contatore),  QMessageBox.Ok)            if bool(dataset) == True:                dataset_sum = self.UTILITY.sum_list_of_tuples_for_value(dataset)                csv_dataset = []                for sing_tup in dataset_sum:                    sing_list = [sing_tup[0], str(sing_tup[1])]                    csv_dataset.append(sing_list)                filename = ('%s%squant_qty.txt') % (self.QUANT_PATH, os.sep)                #QMessageBox.warning(self, "Esportazione", str(filename), MessageBox.Ok)                f = open(filename, 'wb')                Uw = UnicodeWriter(f)                Uw.writerows(csv_dataset)                f.close()                self.plot_chart(dataset_sum, 'Frequency analisys', 'Qty')            else:                QMessageBox.warning(self, "Warning", "The datas not are present",  QMessageBox.Ok)            def parameter_quant_creator(self, par_list, n_rec):        self.parameter_list = par_list        self.record_number = n_rec                converted_parameters = []        for par in self.parameter_list:            converted_parameters.append(self.CONVERSION_DICT[par])                parameter2 = ''        for sing_par_conv in range(len(converted_parameters)):            exec_str =  ('str(self.DATA_LIST[%d].%s)') % (self.record_number, converted_parameters[sing_par_conv])            paramentro = str(self.parameter_list[sing_par_conv])            exec_str = ' -' + paramentro[:4] + ": " + eval(exec_str)            parameter2 += exec_str        return parameter2                    def plot_chart(self, d, t, yl):        self.data_list = d        self.title = t        self.ylabel = yl        if type(self.data_list) == list:            data_diz = {}            for item in self.data_list:                data_diz[item[0]] = item[1]        x = range(len(data_diz))        n_bars = len(data_diz)        values = data_diz.values()        teams = data_diz.keys()        ind = np.arange(n_bars)        #randomNumbers = random.sample(range(0, 10), 10)        self.widget.canvas.ax.clear()        #QMessageBox.warning(self, "Alert", str(teams) ,  QMessageBox.Ok)        bars = self.widget.canvas.ax.bar(left=x, height=values, width=0.5, align='center', alpha=0.4,picker=5)        #guardare il metodo barh per barre orizzontali        self.widget.canvas.ax.set_title(self.title)        self.widget.canvas.ax.set_ylabel(self.ylabel)        l = []        for team in teams:            l.append('""')                    #self.widget.canvas.ax.set_xticklabels(x , ""   ,size = 'x-small', rotation = 0)        n = 0        for bar in bars:            val = int(bar.get_height())            x_pos = bar.get_x() + 0.25            label  = teams[n]+ ' - ' + str(val)            y_pos = 0.1 #bar.get_height() - bar.get_height() + 1            self.widget.canvas.ax.tick_params(axis='x', labelsize=8)            #self.widget.canvas.ax.set_xticklabels(ind + x, ['fg'], position = (x_pos,y_pos), xsize = 'small', rotation = 90)                        self.widget.canvas.ax.text(x_pos, y_pos, label,zorder=0, ha='center', va='bottom',size = 'x-small', rotation = 90)            n+=1        #self.widget.canvas.ax.plot(randomNumbers)        self.widget.canvas.draw()    def enable_button(self, n):        self.pushButton_connect.setEnabled(n)        self.pushButton_new_rec.setEnabled(n)        self.pushButton_view_all.setEnabled(n)        self.pushButton_first_rec.setEnabled(n)        self.pushButton_last_rec.setEnabled(n)        self.pushButton_prev_rec.setEnabled(n)        self.pushButton_next_rec.setEnabled(n)        self.pushButton_delete.setEnabled(n)        self.pushButton_new_search.setEnabled(n)        self.pushButton_search_go.setEnabled(n)        self.pushButton_sort.setEnabled(n)    def enable_button_search(self, n):        self.pushButton_connect.setEnabled(n)        self.pushButton_new_rec.setEnabled(n)        self.pushButton_view_all.setEnabled(n)        self.pushButton_first_rec.setEnabled(n)        self.pushButton_last_rec.setEnabled(n)        self.pushButton_prev_rec.setEnabled(n)        self.pushButton_next_rec.setEnabled(n)        self.pushButton_delete.setEnabled(n)        self.pushButton_save.setEnabled(n)        self.pushButton_sort.setEnabled(n)        self.pushButton_sort.setEnabled(n)            def on_pushButton_connect_pressed(self):        #from pyarchinit_conn_strings import *        conn = Connection()        conn_str = conn.conn_str()        test_conn = conn_str.find('sqlite')        if test_conn == 0:            self.DB_SERVER = "sqlite"        try:            self.DB_MANAGER = Pyarchinit_db_management(conn_str)            self.DB_MANAGER.connection()            self.charge_records() #charge records from DB            #check if DB is empty            if bool(self.DATA_LIST) == True:                self.REC_TOT, self.REC_CORR = len(self.DATA_LIST), 0                self.DATA_LIST_REC_TEMP = self.DATA_LIST_REC_CORR = self.DATA_LIST[0]                self.BROWSE_STATUS = 'b'                self.label_status.setText(self.STATUS_ITEMS[self.BROWSE_STATUS])                self.label_sort.setText(self.SORTED_ITEMS["n"])                self.set_rec_counter(len(self.DATA_LIST), self.REC_CORR+1)                self.charge_list()                self.fill_fields()            else:                QMessageBox.warning(self, "Welcome", "Welcome in pyArchInit" + self.NOME_SCHEDA + ". The database is empty. Press ok and start!",  QMessageBox.Ok)                self.charge_list()                self.BROWSE_STATUS = 'x'                self.on_pushButton_new_rec_pressed()        except Exception as e:            e = str(e)            if e.find("no such table"):                QMessageBox.warning(self, "Alert", "Failed connection<br><br> %s. Is necessary to restart QGIS" % (str(e)),  QMessageBox.Ok)            else:                QMessageBox.warning(self, "Alert", "WARNING! Inform the database programmer, enzo.ccc@gmail.com<br> Error: <br>" + str(e) ,  QMessageBox.Ok)    def customize_GUI(self):                #media prevew system        self.iconListWidget.setLineWidth(2)        self.iconListWidget.setMidLineWidth(2)        self.iconListWidget.setProperty("showDropIndicator", True)        self.iconListWidget.setIconSize(QSize(695, 590))        self.iconListWidget.setMovement(QListView.Snap)        self.iconListWidget.setResizeMode(QListView.Adjust)        self.iconListWidget.setLayoutMode(QListView.Batched)        #self.iconListWidget.setGridSize(QtCore.QSize(2000, 1000))        #self.iconListWidget.setViewMode(QtGui.QListView.IconMode)        self.iconListWidget.setUniformItemSizes(True)        #self.iconListWidget.setBatchSize(1500)        self.iconListWidget.setObjectName("iconListWidget")        self.iconListWidget.SelectionMode()        self.iconListWidget.setSelectionMode(QAbstractItemView.SingleSelection)        self.iconListWidget.itemDoubleClicked.connect(self.openWide_image)                                                     def loadMediaPreview(self, mode = 0):        self.iconListWidget.clear()        conn = Connection()                thumb_path = conn.thumb_path()        thumb_path_str = thumb_path['thumb_path']                if mode == 0:            """ if has geometry column load to map canvas """            rec_list =  self.ID_TABLE + " = " + str(eval("self.DATA_LIST[int(self.REC_CORR)]." + self.ID_TABLE))            search_dict = {'id_entity'  : "'"+str(eval("self.DATA_LIST[int(self.REC_CORR)]." + self.ID_TABLE))+"'", 'entity_type' : "'POTTERY'"}            record_us_list = self.DB_MANAGER.query_bool(search_dict, 'MEDIATOENTITY')            for i in record_us_list:                search_dict = {'id_media' : "'"+str(i.id_media)+"'"}                u = Utility()                search_dict = u.remove_empty_items_fr_dict(search_dict)                mediathumb_data = self.DB_MANAGER.query_bool(search_dict, "MEDIA_THUMB")                thumb_path = str(mediathumb_data[0].filepath)                item = QListWidgetItem(str(i.media_name))                item.setData(Qt.UserRole,str(i.media_name))                icon = QIcon(thumb_path_str+thumb_path)                item.setIcon(icon)                self.iconListWidget.addItem(item)        elif mode == 1:            self.iconListWidget.clear()        def openWide_image(self):        items = self.iconListWidget.selectedItems()        conn = Connection()                        thumb_resize = conn.thumb_resize()        thumb_resize_str = thumb_resize['thumb_resize']        for item in items:            dlg = ImageViewer(self)            id_orig_item = item.text() #return the name of original file            search_dict = {'media_filename' : "'"+str(id_orig_item)+"'"}            u = Utility()            search_dict = u.remove_empty_items_fr_dict(search_dict)            try:                res = self.DB_MANAGER.query_bool(search_dict, "MEDIA_THUMB")                file_path = str(res[0].path_resize)            except Exception as e:                QMessageBox.warning(self, "Errore", "WARNING 1 file: "+ str(e),  QMessageBox.Ok)            dlg.show_image(thumb_resize_str+file_path)            dlg.exec_()    def charge_list(self):        #lista sito        sito_vl = self.UTILITY.tup_2_list_III(self.DB_MANAGER.group_by('site_table', 'sito', 'SITE'))        try:            sito_vl.remove('')        except Exception as e:            if str(e) == "list.remove(x): x not in list":                pass            else:                QMessageBox.warning(self, "Message", "Update system in site list: " + str(e), QMessageBox.Ok)        self.comboBox_sito.clear()                sito_vl.sort()        self.comboBox_sito.addItems(sito_vl)                        sf_vl = self.UTILITY.tup_2_list_III(self.DB_MANAGER.group_by('pottery_table', 'specific_form', 'POTTERY'))        try:            sf_vl.remove('')        except Exception as e:            if str(e) == "list.remove(x): x not in list":                pass            else:                QMessageBox.warning(self, "Message", "Update system in site list: " + str(e), QMessageBox.Ok)        self.comboBox_specific_form.clear()                sf_vl.sort()        self.comboBox_specific_form.addItems(sf_vl)                        f_vl = self.UTILITY.tup_2_list_III(self.DB_MANAGER.group_by('pottery_table', 'form', 'POTTERY'))        try:            f_vl.remove('')        except Exception as e:            if str(e) == "list.remove(x): x not in list":                pass            else:                QMessageBox.warning(self, "Message", "Update system in site list: " + str(e), QMessageBox.Ok)        self.comboBox_form.clear()                f_vl.sort()        self.comboBox_form.addItems(f_vl)                                spceficshape_vl = self.UTILITY.tup_2_list_III(self.DB_MANAGER.group_by('pottery_table', 'specific_shape', 'POTTERY'))        try:            spceficshape_vl.remove('')        except Exception as e:            if str(e) == "list.remove(x): x not in list":                pass            else:                QMessageBox.warning(self, "Message", "Update system in site list: " + str(e), QMessageBox.Ok)        self.comboBox_specific_shape.clear()                spceficshape_vl.sort()        self.comboBox_specific_shape.addItems(spceficshape_vl)                        ware_vl = self.UTILITY.tup_2_list_III(self.DB_MANAGER.group_by('pottery_table', 'ware', 'POTTERY'))        try:            ware_vl.remove('')        except Exception as e:            if str(e) == "list.remove(x): x not in list":                pass            else:                QMessageBox.warning(self, "Message", "Update system in site list: " + str(e), QMessageBox.Ok)        self.comboBox_ware.clear()                ware_vl.sort()        self.comboBox_ware.addItems(ware_vl)                ########lista per l'inserimento delle sigle nel thesaurus##################################################################################        ###################################d_stratigrafica        #search_dict = {        #'nome_tabella'  : "'"+'pottery_table'+"'",        #'tipologia_sigla' : "'"+'Munsell color'+"'"        #}        #munsell = self.DB_MANAGER.query_bool(search_dict, 'PYARCHINIT_THESAURUS_SIGLE')                                #munsell_vl = [ ]        #for i in range(len(munsell)):            #munsell_vl.append(munsell[i].sigla_estesa)        #try:            #munsell_vl ('')        #except:            #pass        #self.comboBox_munsell.clear()        #munsell_vl.sort()        #self.comboBox_munsell.addItems(munsell_vl)    def on_toolButtonPreviewMedia_toggled(self):        if self.toolButtonPreviewMedia.isChecked() == True:            QMessageBox.warning(self, "Messaggio", "Media Preview mode activated. The SU images will be shown in the MEDIA section", QMessageBox.Ok)            self.loadMediaPreview()            selfloadMediaPreview2()        else:            self.loadMediaPreview(1)                self.loadMediaPreview2(1)            def on_pushButton_sort_pressed(self):        if self.check_record_state() == 1:            pass        else:            dlg = SortPanelMain(self)            dlg.insertItems(self.SORT_ITEMS)            dlg.exec_()            items,order_type = dlg.ITEMS, dlg.TYPE_ORDER            self.SORT_ITEMS_CONVERTED = []            for i in items:                #QMessageBox.warning(self, "Messaggio",i, QMessageBox.Ok)                self.SORT_ITEMS_CONVERTED.append(self.CONVERSION_DICT[str(i)]) #apportare la modifica nellle altre schede            self.SORT_MODE = order_type            self.empty_fields()            id_list = []            for i in self.DATA_LIST:                id_list.append(eval("i." + self.ID_TABLE))            self.DATA_LIST = []            temp_data_list = self.DB_MANAGER.query_sort(id_list, self.SORT_ITEMS_CONVERTED, self.SORT_MODE, self.MAPPER_TABLE_CLASS, self.ID_TABLE)            for i in temp_data_list:                self.DATA_LIST.append(i)            self.BROWSE_STATUS = 'b'            self.label_status.setText(self.STATUS_ITEMS[self.BROWSE_STATUS])            if type(self.REC_CORR) == "<type 'str'>":                corr = 0            else:                corr = self.REC_CORR            self.REC_TOT, self.REC_CORR = len(self.DATA_LIST), 0            self.DATA_LIST_REC_TEMP = self.DATA_LIST_REC_CORR = self.DATA_LIST[0]            self.SORT_STATUS = "o"            self.label_sort.setText(self.SORTED_ITEMS[self.SORT_STATUS])            self.set_rec_counter(len(self.DATA_LIST), self.REC_CORR+1)            self.fill_fields()        def insert_new_row(self, table_name):        """insert new row into a table based on table_name"""        cmd = table_name+".insertRow(0)"        eval(cmd)    def remove_row(self, table_name):        """insert new row into a table based on table_name"""        table_row_count_cmd = ("%s.rowCount()") % (table_name)        table_row_count = eval(table_row_count_cmd)        rowSelected_cmd = ("%s.selectedIndexes()") % (table_name)        rowSelected = eval(rowSelected_cmd)        try:            rowIndex = (rowSelected[1].row())            cmd = ("%s.removeRow(%d)") % (table_name, rowIndex)            eval(cmd)        except:            QMessageBox.warning(self, "Messaggio", "Devi selezionare una riga",  QMessageBox.Ok)        def on_pushButton_new_rec_pressed(self):        if bool(self.DATA_LIST) == True:            if self.data_error_check() == 1:                pass            else:                if self.BROWSE_STATUS == "b":                    if bool(self.DATA_LIST) == True:                        if self.records_equal_check() == 1:                            msg = self.update_if(QMessageBox.warning(self,'Error',"The record has been changed. Do you want to save the changes?", QMessageBox.Cancel,1))        if self.BROWSE_STATUS != "n":            self.BROWSE_STATUS = "n"            self.label_status.setText(self.STATUS_ITEMS[self.BROWSE_STATUS])            self.empty_fields()            self.setComboBoxEditable(["self.comboBox_sito"],0)            self.setComboBoxEditable(["self.comboBox_area"],0)            self.setComboBoxEnable(["self.lineEdit_id_number"],"True")            self.setComboBoxEnable(["self.comboBox_sito"],"True")            self.setComboBoxEnable(["self.comboBox_area"],"True")            self.setComboBoxEnable(["self.lineEdit_us"],"True")            #self.setComboBoxEnable(["self.lineEdit_qty"],"True")            self.SORT_STATUS = "n"            self.label_sort.setText(self.SORTED_ITEMS[self.SORT_STATUS])            self.label_status.setText(self.STATUS_ITEMS[self.BROWSE_STATUS])            self.set_rec_counter('','')            self.label_sort.setText(self.SORTED_ITEMS["n"])            self.empty_fields()            self.enable_button(0)    def on_pushButton_save_pressed(self):        #save record        if self.BROWSE_STATUS == "b":            if self.data_error_check() == 0:                if self.records_equal_check() == 1:                    self.update_if(QMessageBox.warning(self,'Warning',"The record has been changed. Do you want to save changes?", QMessageBox.Cancel,1))                    self.SORT_STATUS = "n"                    self.label_sort.setText(self.SORTED_ITEMS[self.SORT_STATUS])                    self.enable_button(1)                    self.fill_fields(self.REC_CORR)                else:                    QMessageBox.warning(self, "Warning", "No changes have been made.",  QMessageBox.Ok)        else:            if self.data_error_check() == 0:                test_insert = self.insert_new_rec()                if test_insert == 1:                    self.empty_fields()                    self.SORT_STATUS = "n"                    self.label_sort.setText(self.SORTED_ITEMS[self.SORT_STATUS])                    self.charge_records()                    self.charge_list()                    self.BROWSE_STATUS = "b"                    self.label_status.setText(self.STATUS_ITEMS[self.BROWSE_STATUS])                    self.REC_TOT, self.REC_CORR = len(self.DATA_LIST), len(self.DATA_LIST)-1                    self.set_rec_counter(self.REC_TOT, self.REC_CORR+1)                    self.setComboBoxEditable(["self.comboBox_sito"],1)                    self.setComboBoxEditable(["self.comboBox_area"],1)                    self.setComboBoxEnable(["self.lineEdit_id_number"],"False")                    self.setComboBoxEnable(["self.comboBox_sito"],"False")                    self.setComboBoxEnable(["self.comboBox_area"],"False")                    self.setComboBoxEnable(["self.lineEdit_us"],"False")                    #self.setComboBoxEnable(["self.lineEdit_qty"],"False")                    self.fill_fields(self.REC_CORR)                    self.enable_button(1)            else:                QMessageBox.warning(self, "Warning", "Problem with data entry",  QMessageBox.Ok)            def insert_new_rec(self):        ##rif_biblio        ##rif_biblio = self.table2dict("self.tableWidget_rif_biblio")                        try:                                                if self.lineEdit_id_number.text() == "":                id_number = None            else:                id_number = int(self.lineEdit_id_number.text())                             if self.lineEdit_us.text() == "":                us = None            else:                us = int(self.lineEdit_us.text())                            if self.lineEdit_box.text() == "":                box = None            else:                box = int(self.lineEdit_box.text())                             if self.lineEdit_bag.text() == "":                bag = None            else:                bag = int(self.lineEdit_bag.text())                                 if self.lineEdit_anno.text() == "":                anno = None            else:                anno = int(self.lineEdit_anno.text())                            if self.lineEdit_diametro_max.text() == "":                diametro_max = None            else:                diametro_max = int(self.lineEdit_diametro_max.text())                                                    if self.lineEdit_qty.text() == "":                qty = None            else:                qty = int(self.lineEdit_qty.text())                         if self.lineEdit_diametro_rim.text() == "":                diametro_rim = None            else:                diametro_rim = int(self.lineEdit_diametro_rim.text())                            if self.lineEdit_diametro_bottom.text() == "":                diametro_bottom = None            else:                diametro_bottom = int(self.lineEdit_diametro_bottom.text())                            if self.lineEdit_diametro_height.text() == "":                diametro_height = None            else:                diametro_height = int(self.lineEdit_diametro_height.text())                            if self.lineEdit_diametro_preserved.text() == "":                diametro_preserved = None            else:                diametro_preserved = int(self.lineEdit_diametro_preserved.text())                            data = self.DB_MANAGER.insert_pottery_values(            self.DB_MANAGER.max_num_id(self.MAPPER_TABLE_CLASS, self.ID_TABLE)+1,                    id_number,                      str(self.comboBox_sito.currentText()),              #1 - Sito                    str(self.comboBox_area.currentText()),              #2 - Area                    us,                                 #3 - US                         box,        #5 - Definizione intepretata                    str(self.lineEdit_photo.text()),        #6 - descrizione                    str(self.comboBox_draw.currentText()),#7 - interpretazione                    anno,           #8 - periodo iniziale                    str(self.comboBox_fabric.currentText()),                                #14 - anno scavo                    str(self.comboBox_percent.currentText()),           #15 - metodo                        str(self.comboBox_material.currentText()),          #9 - fase iniziale                    str(self.comboBox_form.currentText()),          #10 - periodo finale iniziale                    str(self.comboBox_specific_form.currentText()),             #11 - fase finale                    str(self.comboBox_ware.currentText()),          #12 - scavato                    str(self.comboBox_munsell.currentText()),                           #13 - attivita                      str(self.comboBox_surf_trat.currentText()), #22 - conservazione                                             #18 - rapporti                    str(self.comboBox_exdeco.currentText()),                #19 - data schedatura                    str(self.comboBox_intdeco.currentText()),       #20 - schedatore                    str(self.comboBox_wheel_made.currentText()),        #21 - formazione                #23 - colore                    str(self.textEdit_descrip_ex_deco.toPlainText()),                    str(self.textEdit_descrip_in_deco.toPlainText()),#24 - consistenza                    str(self.textEdit_note.toPlainText()),                    diametro_max,                                        ##str(rif_biblio),                    qty,                    diametro_rim,                    diametro_bottom,                    diametro_height,                    diametro_preserved,                                                            str(self.comboBox_specific_shape.currentText()),                    bag,                    )                           #25 - struttura                                                    #28 - documentazione            try:                self.DB_MANAGER.insert_data_session(data)                return 1            except Exception as e:                e_str = str(e)                if e_str.__contains__("IntegrityError"):                    msg = self.ID_TABLE + u" already present in database"                    QMessageBox.warning(self, "Error", "Error"+ str(msg),  QMessageBox.Ok)                else:                    msg = e                    QMessageBox.warning(self, "Error", "Insert error 1 \n"+ str(msg),  QMessageBox.Ok)                return 0        except Exception as e:            QMessageBox.warning(self, "Error", "Insert error 3 \n"+str(e),  QMessageBox.Ok)            return 0    #rif biblio    #def on_pushButton_insert_row_rif_biblio_pressed(self):        #self.insert_new_row('self.tableWidget_rif_biblio')    #def on_pushButton_remove_row_rif_biblio_pressed(self):        #self.remove_row('self.tableWidget_rif_biblio')    def data_error_check(self):        test = 0        EC = Error_check()                if EC.data_is_empty(str(self.lineEdit_id_number.text())) == 0:            QMessageBox.warning(self, "Warning", "Site field. \n This field cannot be empty",  QMessageBox.Ok)            test = 1                    if EC.data_is_empty(str(self.comboBox_sito.currentText())) == 0:            QMessageBox.warning(self, "Warning", "Site field. \n This field cannot be empty",  QMessageBox.Ok)            test = 1        if EC.data_is_empty(str(self.comboBox_area.currentText())) == 0:            QMessageBox.warning(self, "Warning", "Area field. \n This field cannot be empty",  QMessageBox.Ok)            test = 1        if EC.data_is_empty(str(self.lineEdit_us.text())) == 0:            QMessageBox.warning(self, "Warning", "US field. \n >This field cannot be empty",  QMessageBox.Ok)            test = 1        area = self.comboBox_area.currentText()        us = self.lineEdit_us.text()        if us != "":            if EC.data_is_int(us) == 0:                QMessageBox.warning(self, "Warning", "US field. \n The value has to be numeric",  QMessageBox.Ok)                test = 1                        return test                     def check_record_state(self):        ec = self.data_error_check()        if ec == 1:            return 1 #ci sono errori di immissione        elif self.records_equal_check() == 1 and ec == 0:            self.update_if(QMessageBox.warning(self,'Error',"The record has been changed. Do you want to save changes?", QMessageBox.Cancel,1))            #self.charge_records()            return 0 #non ci sono errori di immissione    #records surf functions    #def on_pushButton_view_all_pressed(self):        #self.empty_fields()        #self.charge_records()        #self.fill_fields()        #self.BROWSE_STATUS = "b"        #self.label_status.setText(self.STATUS_ITEMS[self.BROWSE_STATUS])        #if type(self.REC_CORR) == "<type 'str'>":            #corr = 0        #else:            #corr = self.REC_CORR        #self.set_rec_counter(len(self.DATA_LIST), self.REC_CORR+1)        #self.REC_TOT, self.REC_CORR = len(self.DATA_LIST), 0        #self.DATA_LIST_REC_TEMP = self.DATA_LIST_REC_CORR = self.DATA_LIST[0]        #self.SORT_STATUS = "n"        #self.label_sort.setText(self.SORTED_ITEMS[self.SORT_STATUS])    def on_pushButton_view_all_pressed(self):        if self.check_record_state() == 1:            pass        else:            self.empty_fields()            self.charge_records()            self.fill_fields()            self.BROWSE_STATUS = "b"            self.label_status.setText(self.STATUS_ITEMS[self.BROWSE_STATUS])            if type(self.REC_CORR) == "<type 'str'>":                corr = 0            else:                corr = self.REC_CORR            self.set_rec_counter(len(self.DATA_LIST), self.REC_CORR+1)            self.REC_TOT, self.REC_CORR = len(self.DATA_LIST), 0            self.DATA_LIST_REC_TEMP = self.DATA_LIST_REC_CORR = self.DATA_LIST[0]            self.label_sort.setText(self.SORTED_ITEMS["n"])                #records surf functions    def on_pushButton_first_rec_pressed(self):        if self.check_record_state() == 1:                        pass        else:            try:                self.empty_fields()                self.REC_TOT, self.REC_CORR = len(self.DATA_LIST), 0                self.fill_fields(0)                self.set_rec_counter(self.REC_TOT, self.REC_CORR+1)                            except Exception as e:                QMessageBox.warning(self, "Error", str(e),  QMessageBox.Ok)    def on_pushButton_last_rec_pressed(self):        if self.check_record_state() == 1:                        pass        else:            try:                self.empty_fields()                self.REC_TOT, self.REC_CORR = len(self.DATA_LIST), len(self.DATA_LIST)-1                self.fill_fields(self.REC_CORR)                self.set_rec_counter(self.REC_TOT, self.REC_CORR+1)                            except Exception as e:                QMessageBox.warning(self, "Error", str(e),  QMessageBox.Ok)    def on_pushButton_prev_rec_pressed(self):        if self.check_record_state() == 1:            pass        else:            self.REC_CORR = self.REC_CORR-1            if self.REC_CORR == -1:                self.REC_CORR = 0                QMessageBox.warning(self, "Error", "You are on the first record!",  QMessageBox.Ok)            else:                try:                    self.empty_fields()                    self.fill_fields(self.REC_CORR)                    self.set_rec_counter(self.REC_TOT, self.REC_CORR+1)                                    except Exception as e:                    QMessageBox.warning(self, "Error", str(e),  QMessageBox.Ok)    def on_pushButton_next_rec_pressed(self):        if self.check_record_state() == 1:            pass        else:            self.REC_CORR = self.REC_CORR+1            if self.REC_CORR >= self.REC_TOT:                self.REC_CORR = self.REC_CORR-1                QMessageBox.warning(self, "Error", "You are on the last record!",  QMessageBox.Ok)            else:                try:                    self.empty_fields()                    self.fill_fields(self.REC_CORR)                    self.set_rec_counter(self.REC_TOT, self.REC_CORR+1)                                    except Exception as e:                    QMessageBox.warning(self, "Error", str(e),  QMessageBox.Ok)    def on_pushButton_delete_pressed(self):        msg = QMessageBox.warning(self,"Warning!!!","Do you really want to delete the record? \n The action is irreversible", QMessageBox.Cancel,1)        if msg != 1:            QMessageBox.warning(self,"Message!!!","Action cancelled!")        else:            try:                id_to_delete = eval("self.DATA_LIST[self.REC_CORR]." + self.ID_TABLE)                self.DB_MANAGER.delete_one_record(self.TABLE_NAME, self.ID_TABLE, id_to_delete)                self.charge_records() #charge records from DB                QMessageBox.warning(self,"Message!!!","Record deleted!")            except Exception as e:                QMessageBox.warning(self,"Message!!!","Type of Error: "+str(e))            if bool(self.DATA_LIST) == False:                QMessageBox.warning(self, "Warning", "The database is empty!",  QMessageBox.Ok)                self.DATA_LIST = []                self.DATA_LIST_REC_CORR = []                self.DATA_LIST_REC_TEMP = []                self.REC_CORR = 0                self.REC_TOT = 0                self.empty_fields()                self.set_rec_counter(0, 0)            #check if DB is empty            if bool(self.DATA_LIST) == True:                self.REC_TOT, self.REC_CORR = len(self.DATA_LIST), 0                self.DATA_LIST_REC_TEMP = self.DATA_LIST_REC_CORR = self.DATA_LIST[0]                self.BROWSE_STATUS = "b"                self.label_status.setText(self.STATUS_ITEMS[self.BROWSE_STATUS])                self.set_rec_counter(len(self.DATA_LIST), self.REC_CORR+1)                self.charge_list()                self.fill_fields()        self.SORT_STATUS = "n"        self.label_sort.setText(self.SORTED_ITEMS[self.SORT_STATUS])    def on_pushButton_new_search_pressed(self):        if self.check_record_state() == 1:            pass        else:            self.enable_button_search(0)            #set the GUI for a new search            if self.BROWSE_STATUS != "f":                self.BROWSE_STATUS = "f"                ###                self.lineEdit_box.setText("")                self.lineEdit_bag.setText("")                self.lineEdit_anno.setText("")                self.comboBox_fabric.setEditText("")                self.comboBox_ware.setEditText("")                self.setComboBoxEditable(["self.comboBox_sito"],1)                self.setComboBoxEditable(["self.comboBox_area"],1)                self.setComboBoxEnable(["self.lineEdit_id_number"],"True")                self.setComboBoxEnable(["self.comboBox_sito"],"True")                self.setComboBoxEnable(["self.comboBox_area"],"True")                self.setComboBoxEnable(["self.lineEdit_us"],"True")                #self.setComboBoxEnable(["self.lineEdit_qty"],"True")                #self.setTableEnable(["self.tableWidget_rif_biblio"], "False")                ###                self.label_status.setText(self.STATUS_ITEMS[self.BROWSE_STATUS])                self.set_rec_counter('','')                self.label_sort.setText(self.SORTED_ITEMS["n"])                self.charge_list()                self.empty_fields()            def on_pushButton_search_go_pressed(self):        check_for_buttons = 0        if self.BROWSE_STATUS != "f":            QMessageBox.warning(self, "Warning", "To carry out a new search click on the 'new search' button",  QMessageBox.Ok)        else:            #TableWidget                        if self.lineEdit_id_number.text() != "":                id_number = int(self.lineEdit_id_number.text())            else:                id_number = ""            if self.lineEdit_us.text() != "":                us = int(self.lineEdit_us.text())            else:                us = ""            if self.lineEdit_box.text() != "":                box = int(self.lineEdit_box.text())            else:                box = ""                            if self.lineEdit_bag.text() != "":                bag = int(self.lineEdit_bag.text())            else:                bag = ""                            if self.lineEdit_anno.text() != "":                anno = int(self.lineEdit_anno.text())            else:                anno = ""                                                        if self.lineEdit_diametro_max.text() != "":                diametro_max = int(self.lineEdit_diametro_max.text())            else:                diametro_max = ""                                                        if self.lineEdit_qty.text() != "":                qty = int(self.lineEdit_qty.text())             else:                qty = ""                            if self.lineEdit_diametro_rim.text() != "":                diametro_rim = int(self.lineEdit_diametro_rim.text())            else:                diametro_rim = ""                            if self.lineEdit_diametro_bottom.text() != "":                diametro_bottom = int(self.lineEdit_diametro_bottom.text())            else:                diametro_bottom = ""                            if self.lineEdit_diametro_height.text() != "":                diametro_height = int(self.lineEdit_diametro_height.text())            else:                diametro_height = ""                            if self.lineEdit_diametro_preserved.text() != "":                diametro_preserved = int(self.lineEdit_diametro_preserved.text())            else:                diametro_preserved = ""            search_dict = {            self.TABLE_FIELDS[0]  : id_number,                                  #1 - Sito            self.TABLE_FIELDS[1]  : "'"+str(self.comboBox_sito.currentText())+"'",                              #2 - Area            self.TABLE_FIELDS[2]  : "'"+str(self.comboBox_area.currentText())+"'",                                                                                                  #3 - US            self.TABLE_FIELDS[3]  : us,                             #4 - Definizione stratigrafica            self.TABLE_FIELDS[4]  : box,                            #5 - Definizione intepretata            self.TABLE_FIELDS[5]  : "'"+str(self.lineEdit_photo.text())+"'",                                            #6 - descrizione            self.TABLE_FIELDS[6]  : "'"+str(self.comboBox_draw.currentText())+"'",                                      #7 - interpretazione            self.TABLE_FIELDS[7]  : anno,                               #8 - periodo iniziale            self.TABLE_FIELDS[8]  : "'"+str(self.comboBox_fabric.currentText())+"'",                                #9 - fase iniziale            self.TABLE_FIELDS[9]  : "'"+str(self.comboBox_percent.currentText())+"'",                               #10 - periodo finale iniziale            self.TABLE_FIELDS[10] : "'"+str(self.comboBox_material.currentText())+"'",                              #11 - fase finale            self.TABLE_FIELDS[11] : "'"+str(self.comboBox_form.currentText())+"'",                              #12 - scavato             self.TABLE_FIELDS[12] : "'"+str(self.comboBox_specific_form.currentText())+"'",                                             #13 - attivita              self.TABLE_FIELDS[13] : "'"+str(self.comboBox_ware.currentText())+"'",                                                  #14 - anno scavo            self.TABLE_FIELDS[14] : "'"+str(self.comboBox_munsell.currentText())+"'",                               #15 - metodo            self.TABLE_FIELDS[15] : "'"+str(self.comboBox_surf_trat.currentText())+"'",             self.TABLE_FIELDS[16] : "'"+str(self.comboBox_exdeco.currentText())+"'",            self.TABLE_FIELDS[17] : "'"+str(self.comboBox_intdeco.currentText())+"'",            self.TABLE_FIELDS[18] : "'"+str(self.comboBox_wheel_made.currentText())+"'",#16 - data schedatura            self.TABLE_FIELDS[19] : "'"+str(self.textEdit_descrip_ex_deco.toPlainText())+ "'",            self.TABLE_FIELDS[20] : "'"+str(self.textEdit_descrip_in_deco.toPlainText())+ "'",            self.TABLE_FIELDS[21] : "'"+str(self.textEdit_note.toPlainText())+ "'",             #19 - conservazione            self.TABLE_FIELDS[22] : diametro_max,               self.TABLE_FIELDS[23] : qty,            self.TABLE_FIELDS[24] : diametro_rim,                               #15 - metodo            self.TABLE_FIELDS[25] : diametro_bottom,                self.TABLE_FIELDS[26] : diametro_height,            self.TABLE_FIELDS[27] : diametro_preserved,            self.TABLE_FIELDS[28] : "'"+str(self.comboBox_specific_shape.currentText())+"'",            self.TABLE_FIELDS[29]  : bag,               }                                                            u = Utility()            search_dict = u.remove_empty_items_fr_dict(search_dict)            if bool(search_dict) == False:                QMessageBox.warning(self, "Warning", "Insert Value!!!",  QMessageBox.Ok)            else:                res = self.DB_MANAGER.query_bool(search_dict, self.MAPPER_TABLE_CLASS)                if bool(res) == False:                    QMessageBox.warning(self, "Warning", "No records have been found!",  QMessageBox.Ok)                    self.set_rec_counter(len(self.DATA_LIST), self.REC_CORR+1)                    self.DATA_LIST_REC_TEMP = self.DATA_LIST_REC_CORR = self.DATA_LIST[0]                    self.fill_fields(self.REC_CORR)                    self.BROWSE_STATUS = "b"                    self.label_status.setText(self.STATUS_ITEMS[self.BROWSE_STATUS])                    self.setComboBoxEnable(["self.lineEdit_id_number"],"False")                    self.setComboBoxEnable(["self.comboBox_sito"],"False")                    self.setComboBoxEnable(["self.comboBox_area"],"False")                    self.setComboBoxEnable(["self.lineEdit_us"],"False")                    #self.setTableEnable(["self.tableWidget_rif_biblio"], "True")                    check_for_buttons = 1                    #self.fill_fields(self.REC_CORR)                else:                    self.DATA_LIST = []                    for i in res:                        self.DATA_LIST.append(i)                    self.REC_TOT, self.REC_CORR = len(self.DATA_LIST), 0                    self.DATA_LIST_REC_TEMP = self.DATA_LIST_REC_CORR = self.DATA_LIST[0]                    self.fill_fields()                    self.BROWSE_STATUS = "b"                    self.label_status.setText(self.STATUS_ITEMS[self.BROWSE_STATUS])                    self.set_rec_counter(len(self.DATA_LIST), self.REC_CORR+1)                    if self.REC_TOT == 1:                        strings = (self.REC_TOT, "Record has been found")                                            else:                        strings = (self.REC_TOT, "Records have been found")                                            self.setComboBoxEnable(["self.lineEdit_id_number"],"False")                    self.setComboBoxEnable(["self.comboBox_sito"],"False")                    self.setComboBoxEnable(["self.comboBox_area"],"False")                    self.setComboBoxEnable(["self.lineEdit_us"],"False")                    #self.setComboBoxEnable(["self.lineEdit_qty"],"False")                    #self.setTableEnable(["self.tableWidget_rif_biblio"], "True")                                        check_for_buttons = 1                    QMessageBox.warning(self, "Message", "%d %s" % strings,  QMessageBox.Ok)        #self.enable_button_search(1)        if check_for_buttons == 1:            self.enable_button_search(1)                                        def update_if(self, msg):        rec_corr = self.REC_CORR        self.msg = msg        if self.msg == 1:            test = self.update_record()            if test == 1:                id_list = []                for i in self.DATA_LIST:                    id_list.append(eval("i."+ self.ID_TABLE))                self.DATA_LIST = []                if self.SORT_STATUS == "n":                    temp_data_list = self.DB_MANAGER.query_sort(id_list, [self.ID_TABLE], 'asc', self.MAPPER_TABLE_CLASS, self.ID_TABLE) #self.DB_MANAGER.query_bool(self.SEARCH_DICT_TEMP, self.MAPPER_TABLE_CLASS) #                else:                    temp_data_list = self.DB_MANAGER.query_sort(id_list, self.SORT_ITEMS_CONVERTED, self.SORT_MODE, self.MAPPER_TABLE_CLASS, self.ID_TABLE)                for i in temp_data_list:                    self.DATA_LIST.append(i)                self.BROWSE_STATUS = "b"                self.label_status.setText(self.STATUS_ITEMS[self.BROWSE_STATUS])                if type(self.REC_CORR) == "<type 'str'>":                    corr = 0                else:                    corr = self.REC_CORR                 return 1            elif test == 0:                return 0    def update_record(self):        try:            self.DB_MANAGER.update(self.MAPPER_TABLE_CLASS,                         self.ID_TABLE,                        [eval("int(self.DATA_LIST[self.REC_CORR]." + self.ID_TABLE+")")],                        self.TABLE_FIELDS,                        self.rec_toupdate())            return 1        except Exception as e:            QMessageBox.warning(self, "Message", "Encoding problem: accents or characters that are not accepted by the database have been inserted. If you close the window without correcting the errors the data will be lost. Create a copy of everything on a seperate word document. Error :" + str(e), QMessageBox.Ok)            return 0    def rec_toupdate(self):        rec_to_update = self.UTILITY.pos_none_in_list(self.DATA_LIST_REC_TEMP)        return rec_to_update    #custom functions    def charge_records(self):        self.DATA_LIST = []                if self.DB_SERVER == 'sqlite':            for i in self.DB_MANAGER.query(eval(self.MAPPER_TABLE_CLASS)):                self.DATA_LIST.append(i)        else:            id_list = []            for i in self.DB_MANAGER.query(eval(self.MAPPER_TABLE_CLASS)):                id_list.append(eval("i."+ self.ID_TABLE))            temp_data_list = self.DB_MANAGER.query_sort(id_list, [self.ID_TABLE], 'asc', self.MAPPER_TABLE_CLASS, self.ID_TABLE)            for i in temp_data_list:                self.DATA_LIST.append(i)    ###############################################################################        def generate_list_pdf(self):        data_list = []        for i in range(len(self.DATA_LIST)):            data_list.append([            str(self.DATA_LIST[i].id_rep),                          #1 - id_invmat            int(self.DATA_LIST[i].id_number),            str(self.DATA_LIST[i].sito),            str(self.DATA_LIST[i].area),                            #8 - area           #2 - sito            int(self.DATA_LIST[i].us),                  #4 - tipo_reperto            str(self.DATA_LIST[i].box),         #5 - criterio_schedatura            str(self.DATA_LIST[i].photo),                   #6 - definizione            str(self.DATA_LIST[i].drawing),                 #7 - descrizione            str(self.DATA_LIST[i].anno),                                #9 - us            str(self.DATA_LIST[i].fabric),                          #10 - lavato            str(self.DATA_LIST[i].percent),                         #11 - nr_cassa            str(self.DATA_LIST[i].material),        #12 - luogo_conservazione            str(self.DATA_LIST[i].form),        #13 - stato_conservazione            str(self.DATA_LIST[i].specific_form),           #14 - datazione_reperto            str(self.DATA_LIST[i].ware),            #15 - elementi_reperto            str(self.DATA_LIST[i].munsell),                 #16 - misurazioni            str(self.DATA_LIST[i].surf_trat),                       #17 - rif_biblio            str(self.DATA_LIST[i].exdeco),                      #18 - misurazioni            str(self.DATA_LIST[i].intdeco),                             #19 - tipo            str(self.DATA_LIST[i].wheel_made),              #20 - corpo_ceramico            str(self.DATA_LIST[i].descrip_ex_deco),                 #21 - rivestimento            str(self.DATA_LIST[i].descrip_in_deco),                     #22 - repertato            str(self.DATA_LIST[i].note),            str(self.DATA_LIST[i].diametro_max),                        #17 - rif_biblio            str(self.DATA_LIST[i].qty),                     #18 - misurazioni            str(self.DATA_LIST[i].diametro_rim),                                #19 - tipo            str(self.DATA_LIST[i].diametro_bottom),             #20 - corpo_ceramico            str(self.DATA_LIST[i].diametro_height),                 #21 - rivestimento            str(self.DATA_LIST[i].diametro_preserved),                      #22 - repertato            str(self.DATA_LIST[i].specific_shape),            str(self.DATA_LIST[i].bag),     #23 - diagnostico        ])        return data_list            def on_pottery_form_pressed(self):        if self.records_equal_check() == 1:            self.update_if(QMessageBox.warning(self,'Errore',u"Il record  stato modificato. Vuoi salvare le modifiche?", QMessageBox.Cancel,1))        Pottery_pdf_sheet = generate_reperti_pdf()        data_list = self.generate_list_pdf()        Pottery_pdf_sheet.build_Pottery_sheets(data_list)    def on_pottery_list_pressed(self):        Pottery_index_pdf = generate_reperti_pdf()        data_list = self.generate_list_pdf()        Pottery_index_pdf.build_index_Pottery(data_list, data_list[0][0])            ####################################################################################                        def datestrfdate(self):        now = date.today()        today = now.strftime("%d-%m-%Y")        return today    def yearstrfdate(self):        now = date.today()        year = now.strftime("%Y")        return year    def table2dict(self, n):        self.tablename = n        row = eval(self.tablename+".rowCount()")        col = eval(self.tablename+".columnCount()")        lista=[]        for r in range(row):            sub_list = []            for c in range(col):                value = eval(self.tablename+".item(r,c)")                if value != None:                    sub_list.append(str(value.text()))                                if bool(sub_list) == True:                lista.append(sub_list)        return lista    def tableInsertData(self, t, d):        """Set the value into alls Grid"""        self.table_name = t        self.data_list = eval(d)        self.data_list.sort()        #column table count        table_col_count_cmd = ("%s.columnCount()") % (self.table_name)        table_col_count = eval(table_col_count_cmd)        #clear table        table_clear_cmd = ("%s.clearContents()") % (self.table_name)        eval(table_clear_cmd)        for i in range(table_col_count):            table_rem_row_cmd = ("%s.removeRow(%d)") % (self.table_name, i)            eval(table_rem_row_cmd)        for i in range(len(self.data_list)):            self.insert_new_row(self.table_name)                for row in range(len(self.data_list)):            cmd = ('%s.insertRow(%s)') % (self.table_name, row)            eval(cmd)            for col in range(len(self.data_list[row])):                #item = self.comboBox_sito.setEditText(self.data_list[0][col]                item = QTableWidgetItem(str(self.data_list[row][col]))                exec_str = ('%s.setItem(%d,%d,item)') % (self.table_name,row,col)                eval(exec_str)            def empty_fields(self):        #rif_biblio_row_count = self.tableWidget_rif_biblio.rowCount()        self.lineEdit_id_number.clear()         self.comboBox_sito.setEditText("")                                  #1 - Sito        self.comboBox_area.setEditText("")                              #2 - Area        self.lineEdit_us.clear()                                                    #3 - US        self.lineEdit_box.clear()                       #4 - Definizione stratigrafica                  #5 - Definizione intepretata        self.lineEdit_photo.clear()#9 - fase iniziale        self.comboBox_draw.setEditText("")                                  #7 - interpretazione        self.lineEdit_anno.clear()          self.comboBox_fabric.setEditText("")         self.comboBox_percent.setEditText("")        self.comboBox_material.setEditText("")                                  #8 - periodo iniziale        self.comboBox_form.setEditText("")          self.comboBox_specific_form.setEditText("")         self.comboBox_ware.setEditText("")                              #10 - periodo finale iniziale        self.comboBox_munsell.setEditText("")                               #11 - fase finale        self.comboBox_surf_trat.setEditText("")                             #12 - scavato        self.comboBox_exdeco.setEditText("")    #20 - data schedatura                                           #13 - attivita        self.comboBox_intdeco.setEditText("")                       #21 - schedatore        self.comboBox_wheel_made.setEditText("")                #22 - formazione        self.textEdit_descrip_ex_deco.clear()#6 - descrizione        self.textEdit_descrip_in_deco.clear()        self.textEdit_note.clear()        self.lineEdit_diametro_max.clear()                self.lineEdit_qty.clear()        self.lineEdit_diametro_rim.clear()        self.lineEdit_diametro_bottom.clear()        self.lineEdit_diametro_height.clear()        self.lineEdit_diametro_preserved.clear()        self.comboBox_specific_shape.setEditText("")        self.lineEdit_bag.clear()                #for i in range(rif_biblio_row_count):            #self.tableWidget_rif_biblio.removeRow(0)        #self.insert_new_row("self.tableWidget_rif_biblio")                    def fill_fields(self, n=0):        self.rec_num = n        #QMessageBox.warning(self, "check fill fields", str(self.rec_num),  QMessageBox.Ok)        try:            self.lineEdit_id_number.setText(str(self.DATA_LIST[self.rec_num].id_number))    #3 - US            str(self.comboBox_sito.setEditText(self.DATA_LIST[self.rec_num].sito))                                                  #1 - Sito            str(self.comboBox_area.setEditText(self.DATA_LIST[self.rec_num].area))                                              #2 - Area            self.lineEdit_us.setText(str(self.DATA_LIST[self.rec_num].us))            self.lineEdit_box.setText(str(self.DATA_LIST[self.rec_num].box))    #3 - US            str(self.lineEdit_photo.setText(self.DATA_LIST[self.rec_num].photo))            str(self.comboBox_draw.setEditText(self.DATA_LIST[self.rec_num].drawing))            self.lineEdit_anno.setText(str(self.DATA_LIST[self.rec_num].anno))  #3 - US            str(self.comboBox_fabric.setEditText(self.DATA_LIST[self.rec_num].fabric))            str(self.comboBox_percent.setEditText(self.DATA_LIST[self.rec_num].percent))#5 - Definizione intepretata                            str(self.comboBox_material.setEditText(self.DATA_LIST[self.rec_num].material))            str(self.comboBox_form.setEditText(self.DATA_LIST[self.rec_num].form))#5 - Definizione intepretata            str(self.comboBox_specific_form.setEditText(self.DATA_LIST[self.rec_num].specific_form))#5 - Definizione intepretata            str(self.comboBox_ware.setEditText(self.DATA_LIST[self.rec_num].ware))#5 - Definizione intepretata            str(self.comboBox_munsell.setEditText(self.DATA_LIST[self.rec_num].munsell))#5 - Definizione intepretata            str(self.comboBox_surf_trat.setEditText(self.DATA_LIST[self.rec_num].surf_trat))#5 - Definizione intepretata            str(self.comboBox_exdeco.setEditText(self.DATA_LIST[self.rec_num].exdeco))#5 - Definizione intepretata            str(self.comboBox_intdeco.setEditText(self.DATA_LIST[self.rec_num].intdeco))#5 - Definizione intepretata            str(self.comboBox_wheel_made.setEditText(self.DATA_LIST[self.rec_num].wheel_made))#5 - Definizione intepretata            str(self.textEdit_descrip_in_deco.setText(self.DATA_LIST[self.rec_num].descrip_in_deco))                                        #6 - descrizione            str(self.textEdit_descrip_ex_deco.setText(self.DATA_LIST[self.rec_num].descrip_ex_deco))            str(self.textEdit_note.setText(self.DATA_LIST[self.rec_num].note))            #7 - interpretazione                                        #self.comboBox_lavato.setEditText(str(self.DATA_LIST[self.rec_num].lavato))                        #str(self.lineEdit_luogo_conservazione.setText(self.DATA_LIST[self.rec_num].luogo_conservazione))                                                                                #10 - nr_cassa                        #self.lineEdit_nr_cassa.setText(str(self.DATA_LIST[self.rec_num].nr_cassa))                            #self.tableInsertData("self.tableWidget_rif_biblio", self.DATA_LIST[self.rec_num].rif_biblio)                    self.lineEdit_qty.setText(str(self.DATA_LIST[self.rec_num].qty))                        self.lineEdit_diametro_max.setText(str(self.DATA_LIST[self.rec_num].diametro_max))                                                                                        self.lineEdit_diametro_rim.setText(str(self.DATA_LIST[self.rec_num].diametro_rim))            self.lineEdit_diametro_bottom.setText(str(self.DATA_LIST[self.rec_num].diametro_bottom))            self.lineEdit_diametro_height.setText(str(self.DATA_LIST[self.rec_num].diametro_height))                            self.lineEdit_diametro_preserved.setText(str(self.DATA_LIST[self.rec_num].diametro_preserved))                        str(self.comboBox_specific_shape.setEditText(self.DATA_LIST[self.rec_num].specific_shape))            self.lineEdit_bag.setText(str(self.DATA_LIST[self.rec_num].bag))                        if self.toolButtonPreviewMedia.isChecked() == False:                self.loadMediaPreview()                #self.loadMediaPreview2()           except Exception as e:            QMessageBox.warning(self, "Error Fill Fields", str(e),  QMessageBox.Ok)        def set_rec_counter(self, t, c):        self.rec_tot = t        self.rec_corr = c        self.label_rec_tot.setText(str(self.rec_tot))        self.label_rec_corrente.setText(str(self.rec_corr))    def set_LIST_REC_TEMP(self):        ##rif_biblio        #rif_biblio = self.table2dict("self.tableWidget_rif_biblio")                if self.lineEdit_id_number.text() == "":            id_number = None        else:            id_number = self.lineEdit_id_number.text                        if self.lineEdit_us.text() == "":            us = None        else:            us = self.lineEdit_us.text                        if self.lineEdit_box.text() == "":            box = None        else:            box = self.lineEdit_box.text                    if self.lineEdit_bag.text() == "":            bag = None        else:            bag = self.lineEdit_bag.text                            if self.lineEdit_anno.text() == "":            anno = None        else:            anno = self.lineEdit_anno.text                          if self.lineEdit_diametro_max.text() == "":            diametro_max = None        else:            diametro_max = self.lineEdit_diametro_max.text                                if self.lineEdit_qty.text() == "":            qty = None        else:            qty = self.lineEdit_qty.text                    if self.lineEdit_diametro_rim.text() == "":            diametro_rim = None        else:            diametro_rim = self.lineEdit_diametro_rim.text                        if self.lineEdit_diametro_bottom.text() == "":            diametro_bottom = None        else:            diametro_bottom = self.lineEdit_diametro_bottom.text                        if self.lineEdit_diametro_height.text() == "":            diametro_height = None        else:            diametro_height = self.lineEdit_diametro_height.text                        if self.lineEdit_diametro_preserved.text() == "":            diametro_preserved = None        else:            diametro_preserved = self.lineEdit_diametro_preserved.text                        self.DATA_LIST_REC_TEMP = [        str(self.lineEdit_id_number.text()),    #3 - US        str(self.comboBox_sito.currentText()),                      #1 - Sito        str(self.comboBox_area.currentText()),                      #2 - Area        str(self.lineEdit_us.text()),        str(self.lineEdit_box.text()),  #3 - US        str(self.lineEdit_photo.text()),        str(self.comboBox_draw.currentText()),        str(self.lineEdit_anno.text()), #3 - US        str(self.comboBox_fabric.currentText()),        str(self.comboBox_percent.currentText()),        str(self.comboBox_material.currentText()),#4 - Definizione stratigrafica        str(self.comboBox_form.currentText()),        str(self.comboBox_specific_form.currentText()),        str(self.comboBox_ware.currentText()),        str(self.comboBox_munsell.currentText()),        str(self.comboBox_surf_trat.currentText()),        str(self.comboBox_exdeco.currentText()),        str(self.comboBox_intdeco.currentText()),        str(self.comboBox_wheel_made.currentText()),        str(self.textEdit_descrip_ex_deco.toPlainText()),       #6 - descrizione        str(self.textEdit_descrip_in_deco.toPlainText()),        str(self.textEdit_note.toPlainText()),        str(self.lineEdit_diametro_max.text()),                str(self.lineEdit_qty.text()),        str(self.lineEdit_diametro_rim.text()),        str(self.lineEdit_diametro_bottom.text()),        str(self.lineEdit_diametro_height.text()),        str(self.lineEdit_diametro_preserved.text()),        str(self.comboBox_specific_shape.currentText()),        str(self.lineEdit_bag.text()),                #7 - interpretazione        ]    def set_LIST_REC_CORR(self):        self.DATA_LIST_REC_CORR = []        for i in self.TABLE_FIELDS:            self.DATA_LIST_REC_CORR.append(eval("str(self.DATA_LIST[self.REC_CORR]." + i + ")"))    def records_equal_check(self):        self.set_LIST_REC_TEMP()        self.set_LIST_REC_CORR()        #QMessageBox.warning(self, "Error", str(self.DATA_LIST_REC_CORR) + str(self.DATA_LIST_REC_TEMP),  QMessageBox.Ok)        if self.DATA_LIST_REC_CORR == self.DATA_LIST_REC_TEMP:            return 0        else:            return 1    def setComboBoxEditable(self, f, n):        field_names = f        value = n        for fn in field_names:            cmd = ('%s%s%d%s') % (fn, '.setEditable(', n, ')')            eval(cmd)    def setComboBoxEnable(self, f, v):        field_names = f        value = v        for fn in field_names:            cmd = ('%s%s%s%s') % (fn, '.setEnabled(', v, ')')            eval(cmd)                def setTableEnable(self, t, v):        tab_names = t        value = v        for tn in tab_names:            cmd = ('%s%s%s%s') % (tn, '.setEnabled(', v, ')')            eval(cmd)    def testing(self, name_file, message):        f = open(str(name_file), 'w')        f.write(str(message))        f.close()        def on_pottery_form_pressed(self):        pottery_pdf_sheet = generate_POTTERY_pdf()        data_list = self.generate_list_pdf()        pottery_pdf_sheet.build_POTTERY_sheets(data_list)    def generate_list_pdf2(self):        data_list = []        for i in range(len(self.DATA_LIST)):            data_list.append([            str(self.DATA_LIST[i].divelog_id),                                  #1 - Sito            str(self.DATA_LIST[i].artefact_id),                                 #2 -             str(self.DATA_LIST[i].years)            ])        return data_list        def on_pottery_list_pressed(self):        POTTERY_index_pdf = generate_POTTERY_pdf()        data_list = self.generate_list_pdf2()        POTTERY_index_pdf.build_index_POTTERY(data_list, data_list[0][0])       def on_pushButton_open_dir_pressed(self):        HOME = os.environ['PYARCHINIT_HOME']        path = '{}{}{}'.format(HOME, os.sep, "pyarchinit_PDF_folder")        if platform.system() == "Windows":            os.startfile(path)        elif platform.system() == "Darwin":            subprocess.Popen(["open", path])        else:            subprocess.Popen(["xdg-open", path])